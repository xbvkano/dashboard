datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
   binaryTargets = ["native"]
}

enum UserType {
  Google
  password
}

model User {
  id       Int      @id @default(autoincrement())
  email    String?  @unique
  name     String?
  role     Role     @default(EMPLOYEE)
  safe     Boolean  @default(false)
  type     UserType @default(Google)
  password String?
  userName String?  @unique

  appointments Appointment[] @relation("AdminAppointments")
  employee     Employee?
  supervisedEmployees Employee[] @relation("SupervisedEmployees")
}

model Client {
  id                   Int                    @id @default(autoincrement())
  name                 String                 @unique
  number               String
  from                 String?
  notes                String?
  disabled             Boolean                @default(false)
  appointments         Appointment[]
  appointmentTemplates AppointmentTemplate[]
}

model Employee {
  id            Int                        @id @default(autoincrement())
  name          String                     @unique
  number        String
  notes         String?
  experienced   Boolean                    @default(false)
  disabled      Boolean                    @default(false)
  userId        Int?                       @unique
  user          User?                      @relation(fields: [userId], references: [id])
  supervisorId  Int?
  supervisor    User?                      @relation("SupervisedEmployees", fields: [supervisorId], references: [id], onDelete: SetNull)
  appointments  Appointment[]              @relation("AppointmentEmployees")
  schedule      Schedule?

  prevBalance  Float                      @default(0)
  lastPaidAt   DateTime?

  payrollItems PayrollItem[]       @relation("EmployeePayrollItems")
  payments     EmployeePayment[]   @relation("EmployeePayments")
  manualItems  ManualPayrollItem[]

  templateLinks EmployeeTemplateEmployee[] @relation("EmployeeOnTemplate")
}

model Appointment {
  id              Int             @id @default(autoincrement())
  date            DateTime
  time            String
  adminId        Int
  admin          User            @relation("AdminAppointments", fields: [adminId], references: [id])
  clientId        Int
  client          Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  type            AppointmentType
  address         String
  cityStateZip    String?
  size            String?
  teamSize        Int             @default(1)
  hours           Int?
  price           Float?
  paid            Boolean         @default(false)
  paymentMethod   PaymentMethod
  tip             Float           @default(0)
  noTeam          Boolean         @default(false)
  carpetRooms     Int?
  carpetPrice     Float?
  carpetEmployees Int[]
  status          AppointmentStatus @default(APPOINTED)
  observe         Boolean         @default(false)
  observation     String?
  infoSent        Boolean         @default(false)
  lineage         String
  gateCode        String?
  doorCode        String?
  buildingNumber  String?
  notes           String?
  payrollNote     String?         // Pay note from Team Options (per appointment only)
  aiCreated       Boolean         @default(false)
  familyId        Int?
  family          RecurrenceFamily? @relation(fields: [familyId], references: [id], onDelete: SetNull)
  templateId      Int?
  template        AppointmentTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  createdAt       DateTime?       @default(now())
  updatedAt       DateTime?       @updatedAt

  employees       Employee[]      @relation("AppointmentEmployees")
  payrollItems   PayrollItem[]
}

model RecurrenceFamily {
  id                Int       @id @default(autoincrement())
  status            String    @default("active") // "active" | "stopped"
  recurrenceRule    String    // JSON string containing rule configuration
  nextAppointmentDate DateTime?
  templateId        Int?
  template          AppointmentTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  appointments      Appointment[]
}

model AppointmentTemplate {
  id                Int                @id @default(autoincrement())
  templateName      String
  type              AppointmentType
  size              String
  teamSize          Int                @default(1)
  address           String
  cityStateZip      String?
  price             Float
  instructions     String?
  notes            String?
  carpetRooms      Int?
  carpetPrice      Float?
  clientId          Int
  client            Client             @relation(fields: [clientId], references: [id], onDelete: Cascade)
  employeeTemplates EmployeeTemplate[]
  appointments      Appointment[]
  recurrenceFamilies RecurrenceFamily[]
  createdAt         DateTime?          @default(now())
  updatedAt         DateTime?          @updatedAt
}

model EmployeeTemplate {
  id                    Int                       @id @default(autoincrement())
  templateName          String
  appointmentTemplateId Int
  appointmentTemplate   AppointmentTemplate       @relation(fields: [appointmentTemplateId], references: [id], onDelete: Cascade)
  employees             EmployeeTemplateEmployee[]
  totalPrice            Float                     @default(0)

  createdAt             DateTime?                 @default(now())
  updatedAt             DateTime?                 @updatedAt
}

model EmployeeTemplateEmployee {
  id                 Int       @id @default(autoincrement())
  employeeId         Int
  price              Float

  employeeTemplateId Int
  employeeTemplate   EmployeeTemplate @relation(fields: [employeeTemplateId], references: [id])

  employee           Employee @relation("EmployeeOnTemplate", fields: [employeeId], references: [id], onDelete: Cascade)
}

enum PaymentMethod {
  ZELLE
  VENMO
  CASH
  PAYPAL
  CHECK
  OTHER
}

enum AppointmentType {
  STANDARD
  DEEP
  MOVE_IN_OUT
}

enum Role {
  EMPLOYEE
  ADMIN
  OWNER
  SUPERVISOR
}

enum AppointmentStatus {
  APPOINTED
  RESCHEDULE_NEW
  RESCHEDULE_OLD
  CANCEL
  REBOOK
  REOCCURRING
  RECURRING_UNCONFIRMED
  DELETED
}

model Invoice {
  id          String   @id @default(uuid()) @db.Uuid
  number      String?  @unique
  clientName  String
  billedTo    String
  address     String
  city        String?
  state       String?
  zip         String?
  serviceDate DateTime
  serviceTime String
  serviceType String
  price       Float
  carpetPrice Float?
  discount    Float?
  taxPercent  Float?
  comment     String?
  otherItems  Json?
  paid        Boolean  @default(true)
  total       Float
  createdAt   DateTime @default(now())
}

model PayrollItem {
  id              Int          @id @default(autoincrement())
  appointmentId   Int
  employeeId      Int
  amount          Float?       // override base pay; if null, computed from type/size/count
  confirmed       Boolean      @default(false) // employee has confirmed this job (Upcoming Jobs)
  reminderSentAt  DateTime?    // when we sent the employee an SMS about this unconfirmed job (within 14 days)
  paid            Boolean      @default(false)
  paymentId       Int?
  extras          ManualPayrollItem[] @relation("ExtraItems")

  appointment   Appointment  @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  employee      Employee     @relation("EmployeePayrollItems", fields: [employeeId], references: [id], onDelete: Cascade)
  payment       EmployeePayment? @relation(fields: [paymentId], references: [id])
}

model EmployeePayment {
  id         Int       @id @default(autoincrement())
  employeeId Int
  amount     Float
  extra      Float      @default(0)
  createdAt  DateTime   @default(now())

  employee   Employee   @relation("EmployeePayments", fields: [employeeId], references: [id], onDelete: Cascade)
  items      PayrollItem[]
  manualItems ManualPayrollItem[]
}

model ManualPayrollItem {
  id         Int       @id @default(autoincrement())
  employeeId Int
  name       String
  amount     Float
  paid       Boolean   @default(false)
  paymentId  Int?
  payrollItemId Int?
  createdAt  DateTime  @default(now())

  employee  Employee        @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  payment   EmployeePayment? @relation(fields: [paymentId], references: [id])
  payrollItem PayrollItem?   @relation("ExtraItems", fields: [payrollItemId], references: [id])
}

model Schedule {
  id                      Int       @id @default(autoincrement())
  employeeId              Int       @unique
  futureSchedule          String[]  @default([])
  pastSchedule            String[]  @default([])
  employeeUpdate          DateTime? @default(now())
  nextScheduleUpdateDueAt DateTime? // date (start of day) by which employee must update; when they update we set to next policy day
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  employee                Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
}

// Admin-only: projected team size for days more than 14 days from today (used for capacity display; future: enforce at booking).
model ScheduleProjection {
  id          Int      @id @default(autoincrement())
  amTeamSize  Int      @default(0)
  pmTeamSize  Int      @default(0)
  updatedAt   DateTime @updatedAt
}

// Global schedule reminder policy (single row, id=1). Days are counted after missing the update day (day 1 = first day after update day).
model SchedulePolicy {
  id                       Int   @id @default(autoincrement())
  updateDayOfWeek          Int   @default(0)   // 0=Sunday..6=Saturday â€“ day by which employees should update
  supervisorNotifyAfterDays Int   @default(4)  // from this day past the update day, also notify supervisor
  stopRemindingAfterDays   Int   @default(7)   // stop all reminders after this many days past the update day
  updatedAt                DateTime @updatedAt
}
